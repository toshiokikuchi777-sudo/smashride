--// CanService.lua
--// ç¼¶ãŒæ½°ã‚ŒãŸã¨ãã®ã‚µãƒ¼ãƒãƒ¼å‡¦ç†ï¼šã‚¹ã‚³ã‚¢åŠ ç®— & ãƒªã‚¹ãƒãƒ¼ãƒ³ + ãƒãƒ³ãƒãƒ¼è§£é™¤åˆ¤å®š + ã‚¢ãƒ“ãƒªãƒ†ã‚£

local Players           = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local ServerStorage     = game:GetService("ServerStorage")

local Remotes           = ReplicatedStorage:WaitForChild("Remotes")
local CanCrushedEvent   = Remotes:WaitForChild("CanCrushed")
local ScrapChangedEvent = Remotes:WaitForChild("ScrapChanged")
local ScoreChangedEvent = Remotes:WaitForChild("ScoreChanged")
local SetEquippedHammer = Remotes:WaitForChild("SetEquippedHammer")
local EquipHammerRequest = Remotes:WaitForChild("EquipHammerRequest")
local CrushCanVisual    = Remotes:WaitForChild("CrushCanVisual")
local ShockwaveVFX      = Remotes:WaitForChild("ShockwaveVFX")
local MultiplierVFX     = Remotes:WaitForChild("MultiplierVFX")

-- GameConfig, Math
local GameConfig = require(ReplicatedStorage:WaitForChild("Shared"):WaitForChild("Config"):WaitForChild("GameConfig"))
local EffectMath = require(ReplicatedStorage:WaitForChild("Shared"):WaitForChild("Math"):WaitForChild("EffectMath"))
local ScoreMath  = require(ReplicatedStorage:WaitForChild("Shared"):WaitForChild("Math"):WaitForChild("ScoreMath"))

local CanService = {}

----------------------------------------------------------------
-- å†…éƒ¨å®šæ•° / çŠ¶æ…‹ç®¡ç†
----------------------------------------------------------------
local playerScores = {}
local shockwaveCooldowns = {}

local CRUSH_SHOW_TIME = 1.0
local RESPAWN_DELAY = 3.0

-- ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆå–å¾—
local CansTemplate = ServerStorage:FindFirstChild("Templates") and ServerStorage.Templates:FindFirstChild("Cans")
if not CansTemplate then
    -- ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: Workspaceå†…ã«Cansãƒ•ã‚©ãƒ«ãƒ€ãŒã‚ã‚Œã°ãã“ã‹ã‚‰å–å¾—ã‚’è©¦ã¿ã‚‹ï¼ˆæ—¢å­˜ã‚³ãƒ¼ãƒ‰äº’æ›ï¼‰
    CansTemplate = workspace:FindFirstChild("Cans")
end

----------------------------------------------------------------
-- å†…éƒ¨é–¢æ•°
----------------------------------------------------------------
local function getPlayerScore(player)
	if not playerScores[player] then
		playerScores[player] = { 
            total = 0, 
            last = "", 
            red = 0, 
            blue = 0, 
            green = 0, 
            purple = 0, 
            yellow = 0 
        }
	end
	return playerScores[player]
end


----------------------------------------------------------------
-- ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ / ã‚µãƒ¼ãƒ“ã‚¹å–å¾— (Lazy Load)
----------------------------------------------------------------
-- DataService
local DataService = nil
local function getDataService()
	if not DataService then
		DataService = require(game:GetService("ServerScriptService").Services.DataService)
	end
	return DataService
end

-- UnlockService
local UnlockService = nil
local function getUnlockService()
	if not UnlockService then
		UnlockService = require(game:GetService("ServerScriptService").Services.UnlockService)
	end
	return UnlockService
end

local function pushScore(player)
	local scores = getPlayerScore(player)
	ScoreChangedEvent:FireClient(player, scores)
	ScrapChangedEvent:FireClient(player, scores.total)
	
	-- ç´¯è¨ˆç ´å£Šæ•°ã‚‚é€ä¿¡
	local DS = getDataService()
	local data = DS.Get(player)
	if data then
		local Net = require(ReplicatedStorage.Shared.Net)
		local cansSmashed = Net.E("CansSmashed")
		if cansSmashed then
			print("[CanService/pushScore] Sending CansSmashed:", data.cansSmashedTotal or 0, "to", player.Name)
			cansSmashed:FireClient(player, data.cansSmashedTotal or 0)
		else
			warn("[CanService/pushScore] CansSmashed event not found!")
		end
	else
		warn("[CanService/pushScore] Player data not found for:", player.Name)
	end
end

----------------------------------------------------------------
-- ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ / ã‚µãƒ¼ãƒ“ã‚¹å–å¾— (Lazy Load)
----------------------------------------------------------------
-- DataService
local DataService = nil
local function getDataService()
	if not DataService then
		DataService = require(game:GetService("ServerScriptService").Services.DataService)
	end
	return DataService
end

-- UnlockService
local UnlockService = nil
local function getUnlockService()
	if not UnlockService then
		UnlockService = require(game:GetService("ServerScriptService").Services.UnlockService)
	end
	return UnlockService
end

-- EffectState
local EffectState = nil
local function getEffectState()
	if not EffectState then
		EffectState = require(game:GetService("ServerScriptService").Services.EffectState)
	end
	return EffectState
end

-- PetEffectService
local PetEffectService = nil
local function getPetEffectService()
	if not PetEffectService then
		local ServerScriptService = game:GetService("ServerScriptService")
		PetEffectService = require(ServerScriptService.Services.PetEffectService)
	end
	return PetEffectService
end

----------------------------------------------------------------
-- è§£æ”¾çŠ¶æ…‹ã®åŒæœŸ
----------------------------------------------------------------
local function syncUnlockState(player)
	local DS = getDataService()
	local data = DS.Get(player)
	local US = getUnlockService()
	if data and US then
		local payload = US.BuildSyncPayload(data)
		local Net = require(ReplicatedStorage.Shared.Net)
		Net.E("UnlockStateSync"):FireClient(player, payload)
		-- print("[CanService/UnlockSync] Sent to", player.Name)
	end
end

----------------------------------------------------------------
-- ç¼¶ã®è‰² / ãƒã‚¤ãƒ³ãƒˆè¨ˆç®—ã®ç´”é–¢æ•°
----------------------------------------------------------------
local function getCanColor(canName)
	local name = (canName or ""):lower()
	if name:find("red") then return "RED"
	elseif name:find("blue") then return "BLUE"
	elseif name:find("green") then return "GREEN"
	elseif name:find("purple") then return "PURPLE"
	elseif name:find("yellow") then return "YELLOW"
	else return nil
	end
end


----------------------------------------------------------------
-- ã‚¹ãƒ†ãƒ¼ã‚¸è‡ªå‹•é€²è¡Œãƒã‚§ãƒƒã‚¯
----------------------------------------------------------------
local function checkStageProgression(player)
	local DS = getDataService()
	local data = DS.Get(player)
	if not data then return end
	
	local currentStage = data.stage or 1
	local smashed = data.cansSmashedTotal or 0
	
	-- æ¬¡ã®ã‚¹ãƒ†ãƒ¼ã‚¸ã®æ¡ä»¶ã‚’ãƒã‚§ãƒƒã‚¯
	local requirements = GameConfig.StageRequirements
	if not requirements then return end
	
	local nextStage = currentStage + 1
	local requirement = requirements[nextStage]
	
	if requirement and smashed >= requirement.cansSmashedTotal then
		data.stage = nextStage
		DS.MarkDirty(player)
		
		-- ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã«é€šçŸ¥
		local Net = require(ReplicatedStorage.Shared.Net)
		local event = Net.E("StageUp")
		if event then
			event:FireClient(player, {
				newStage = nextStage,
				cansSmashedTotal = smashed
			})
		end
		
		print("[CanService] ğŸ‰ Player", player.Name, "reached Stage", nextStage, "with", smashed, "cans smashed!")
		
		-- è§£æ”¾çŠ¶æ…‹ã‚’å†åŒæœŸ
		syncUnlockState(player)
	end
end

----------------------------------------------------------------
-- ãƒãƒ³ãƒãƒ¼åˆ¥ã®ãƒã‚¤ãƒ³ãƒˆè¨ˆç®—
----------------------------------------------------------------
local function calculatePoints(player, canColor)
	local hammerType = player:GetAttribute("EquippedHammer") or "BASIC"
	local hammerConfig = GameConfig.Hammers and GameConfig.Hammers[hammerType]
	local canConfig = GameConfig.CanTypes and GameConfig.CanTypes[canColor]
	
	local basePoint = (canConfig and canConfig.point) or 1
	
	-- ãƒãƒ³ãƒãƒ¼å€ç‡
	local hammerMult = 1.0
	if hammerConfig and hammerConfig.multipliers and canColor then
		hammerMult = hammerConfig.multipliers[canColor] or 1.0
	end
	
	-- ãƒšãƒƒãƒˆå€ç‡ï¼ˆPetEffectService çµŒç”±ï¼‰
	local petMult = 1.0
	local PES = getPetEffectService()
	if PES then
		petMult = PES.getPetBonusMult(player)
	end
	
	-- [æŒ‡ç¤ºæ›¸ 4/4] ç´”é–¢æ•°ã«ã‚ˆã‚‹è¨ˆç®—
	local totalMult = EffectMath.CalcTotalMult(hammerMult, petMult)
	local finalPoint = ScoreMath.CalcHitGain(basePoint, totalMult)
	
	-- ãƒ‡ãƒãƒƒã‚°ãƒ­ã‚°ï¼ˆæŒ‡ç¤ºæ›¸ 4/4 æº–æ‹ ï¼‰
	print(("[Score] base=%d hm=%.2f pm=%.2f tm=%.2f gain=%d"):format(basePoint, hammerMult, petMult, totalMult, finalPoint))
	
	-- ãƒãƒ³ãƒãƒ¼å€ç‡ãŒ1ã‚ˆã‚Šå¤§ãã„å ´åˆã€è¦–è¦šåŠ¹æœã‚’é€šçŸ¥
	if hammerMult > 1 then
		MultiplierVFX:FireClient(player, canColor, hammerMult, finalPoint)
	end
	
	-- ç´¯è¨ˆç ´å£Šæ•°ã‚’åŠ ç®— (æŒ‡ç¤ºæ›¸ 5/8)
	local DS = getDataService()
	if DS then
		local data = DS.Get(player)
		if data then
			local oldCount = data.cansSmashedTotal or 0
			data.cansSmashedTotal = oldCount + 1
			print("[CanService/calculatePoints] CansSmashed:", oldCount, "->", data.cansSmashedTotal, "for", player.Name)
			DS.MarkDirty(player)
			syncUnlockState(player) -- æŒ‡ç¤ºæ›¸ 8/8: åŒæœŸ
			
			-- ã‚¹ãƒ†ãƒ¼ã‚¸é€²è¡Œãƒã‚§ãƒƒã‚¯
			checkStageProgression(player)
		end
	end

	return finalPoint
end


----------------------------------------------------------------
-- ã‚¹ã‚³ã‚¢åŠ ç®—ï¼ˆè‰²åˆ¥å¯¾å¿œ + ãƒãƒ³ãƒãƒ¼å€ç‡ï¼‰
----------------------------------------------------------------
function CanService.addScrap(player, canName)
	local scores = getPlayerScore(player)
	local color = getCanColor(canName or "")
	local colorLower = color and color:lower() or nil
	
	local points = calculatePoints(player, color)
	
	scores.total = scores.total + points
	if colorLower and scores[colorLower] then
		scores[colorLower] = scores[colorLower] + 1
	end
	scores.last = string.format("+%d (%s)", points, color or "?")
	
	pushScore(player)
	
	-- DataService ã®ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚‚åŒæœŸæ›´æ–°
	local DS = getDataService()
	if DS then
		local data = DS.Get(player)
		if data then
			data.total = scores.total
		end
		DS.MarkDirty(player)
	end
	
	return points
end

----------------------------------------------------------------
-- public: ç¾åœ¨ã®ã‚¹ã‚³ã‚¢ã‚’å–å¾— (DataService Saveç”¨)
----------------------------------------------------------------
function CanService.GetTotalScore(player)
	local scores = getPlayerScore(player)
	return scores.total or 0
end

----------------------------------------------------------------
-- public: ã‚¹ã‚³ã‚¢ã‚’ã‚»ãƒƒãƒˆ (DataService Loadç”¨ / ã‚¬ãƒãƒ£ç­‰ã§ã®æ¶ˆè²»ç”¨)
----------------------------------------------------------------
function CanService.SetTotalScore(player, value, lastText)
	local scores = getPlayerScore(player)
	scores.total = value or 0
	if lastText then
		scores.last = lastText
	end
	pushScore(player)
end

----------------------------------------------------------------
-- ç¼¶ã‚’æ½°ã™å‡¦ç†ï¼ˆè¦–è¦šåŠ¹æœã‚’ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã«é€šçŸ¥ï¼‰
----------------------------------------------------------------
local function crushCan(canModel, player, isShockwave)
	if not canModel or not canModel.Parent then return 0 end
	if canModel:GetAttribute("ServerHandled") then return 0 end
	canModel:SetAttribute("ServerHandled", true)
	
	local canName = canModel.Name
	local crushPivot = canModel:GetPivot()
	
	local points = CanService.addScrap(player, canName)
	
	-- ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã«è¦–è¦šåŠ¹æœã‚’é€šçŸ¥ï¼ˆshockwave ã§æ½°ã•ã‚ŒãŸç¼¶ã‚‚å«ã‚€ï¼‰
	CrushCanVisual:FireAllClients(canModel)
	
	if isShockwave then
		print("[CanService] Shockwave crushed:", canName)
	else
		print("[CanService] CanCrushed by", player.Name, ":", canName)
	end
	
	task.delay(CRUSH_SHOW_TIME, function()
		if not canModel.Parent then return end
		canModel:Destroy()
		task.delay(RESPAWN_DELAY, function()
			CanService.respawnCan(canName, crushPivot)
		end)
	end)
	
	return points
end

----------------------------------------------------------------
-- SHOCKWAVE èƒ½åŠ›ï¼šå‘¨å›²ã®ç¼¶ã‚’æ½°ã™
----------------------------------------------------------------
local function doShockwave(player, centerPosition, radius)
	local cansFolder = workspace:FindFirstChild("Cans")
	if not cansFolder then return 0 end
	
	local hitBaseScores = {}
	local cansToCrush = {}
	
	for _, can in ipairs(cansFolder:GetChildren()) do
		if can:IsA("Model") and not can:GetAttribute("ServerHandled") then
			local canPos = can:GetPivot().Position
			local distance = (canPos - centerPosition).Magnitude
			
			if distance <= radius then
				local color = getCanColor(can.Name)
				local canConfig = GameConfig.CanTypes and GameConfig.CanTypes[color]
				table.insert(hitBaseScores, (canConfig and canConfig.point) or 1)
				table.insert(cansToCrush, can)
			end
		end
	end
	
	if #cansToCrush == 0 then return 0 end
	
	-- å€ç‡å–å¾—
	local hammerType = player:GetAttribute("EquippedHammer") or "BASIC"
	local hammerConfig = GameConfig.Hammers and GameConfig.Hammers[hammerType]
	local hammerMult = (hammerConfig and hammerConfig.multipliers and hammerConfig.multipliers.NORMAL) or 1.0 -- ä»®
	
	local petMult = 1.0
	local PES = getPetEffectService()
	if PES then petMult = PES.getPetBonusMult(player) end
	
	local totalMult = EffectMath.CalcTotalMult(hammerMult, petMult)
	local totalPoints, sumBase = ScoreMath.CalcShockwaveGain(hitBaseScores, totalMult, "list")
	
	-- å€‹åˆ¥ç²‰ç •ï¼ˆã‚¹ã‚³ã‚¢åŠ ç®—ãªã—ã€‚ä¸€æ‹¬ã§åŠ ç®—ã™ã‚‹ãŸã‚ï¼‰
	for _, can in ipairs(cansToCrush) do
		can:SetAttribute("ServerHandled", true)
		local canName = can.Name
		local crushPivot = can:GetPivot()
		CrushCanVisual:FireAllClients(can)
		
		task.delay(CRUSH_SHOW_TIME, function()
			if not can.Parent then return end
			can:Destroy()
			task.delay(RESPAWN_DELAY, function()
				CanService.respawnCan(canName, crushPivot)
			end)
		end)
	end
	
	-- ã‚¹ã‚³ã‚¢ä¸€æ‹¬åŠ ç®—
	local scores = getPlayerScore(player)
	scores.total = scores.total + totalPoints
	scores.last = string.format("+%d (SHOCKWAVE)", totalPoints)
	pushScore(player)
	
	-- DataService åŒæœŸ & ç´¯è¨ˆç ´å£Šæ•°åŠ ç®— (æŒ‡ç¤ºæ›¸ 5/8)
	local DS = getDataService()
	if DS then
		local data = DS.Get(player)
		if data then 
			data.total = scores.total 
			data.cansSmashedTotal = (data.cansSmashedTotal or 0) + #cansToCrush
			DS.MarkDirty(player)
			syncUnlockState(player) -- æŒ‡ç¤ºæ›¸ 8/8: åŒæœŸ
		end
	end
	
	print(("[Score] SHOCKWAVE sumBase=%d tm=%.2f gain=%d smashed=%d"):format(sumBase, totalMult, totalPoints, #cansToCrush))
	
	return totalPoints
end

----------------------------------------------------------------
-- ç¼¶ã‚’ãƒ†ãƒ³ãƒ—ãƒ¬ã‹ã‚‰è¤‡è£½ã—ã¦åŒã˜ä½ç½®ã«å‡ºã™
----------------------------------------------------------------
function CanService.respawnCan(canName, pivotCFrame)
	local template = CansTemplate:FindFirstChild(canName)
	if not template then
		local wCans = workspace:FindFirstChild("Cans")
		if wCans then
			local sample = wCans:FindFirstChild(canName)
			if sample then template = sample end
		end
	end
	if not template then
		warn("[CanService] template not found for:", canName)
		return
	end
	local newCan = template:Clone()
	newCan.Name = canName
	
	-- [FIX] å…¨ã¦ã®å±æ€§ã‚’ã‚¯ãƒªã‚¢ã—ã¦æ–°é®®ãªçŠ¶æ…‹ã«ã™ã‚‹
	for _, attr in ipairs(newCan:GetAttributes()) do
		newCan:SetAttribute(attr, nil)
	end
	
	newCan:PivotTo(pivotCFrame)
	local cansRoot = workspace:FindFirstChild("Cans")
	if not cansRoot then
		cansRoot = Instance.new("Folder")
		cansRoot.Name = "Cans"
		cansRoot.Parent = workspace
	end
	newCan.Parent = cansRoot
	print("[CanService] respawn:", canName, "- attributes cleared")
end

----------------------------------------------------------------
-- ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼åˆæœŸåŒ–ï¼ˆãƒãƒ³ãƒãƒ¼å±æ€§ã‚’è¨­å®šï¼‰
----------------------------------------------------------------
local function initPlayer(player)
	if not player:GetAttribute("EquippedHammer") then
		player:SetAttribute("EquippedHammer", "BASIC")
		print("[CanService] Set initial hammer for", player.Name, "-> BASIC")
	end
	task.delay(1, function()
		pushScore(player)
		syncUnlockState(player) -- æŒ‡ç¤ºæ›¸ 8/8: åˆæœŸåŒæœŸ
		
		-- ç´¯è¨ˆç ´å£Šæ•°ã®åˆæœŸå€¤ã‚‚é€ä¿¡
		local DS = getDataService()
		local data = DS.Get(player)
		if data then
			local Net = require(ReplicatedStorage.Shared.Net)
			local cansSmashed = Net.E("CansSmashed")
			if cansSmashed then
				cansSmashed:FireClient(player, data.cansSmashedTotal or 0)
				print("[CanService] Sent initial cansSmashedTotal to", player.Name, ":", data.cansSmashedTotal or 0)
			end
		end
	end)
end

----------------------------------------------------------------
-- åˆæœŸåŒ–
----------------------------------------------------------------
function CanService.Init()
	print("CanService.Init (With Shockwave + Visual)")
	
	for _, player in ipairs(Players:GetPlayers()) do
		initPlayer(player)
	end
	Players.PlayerAdded:Connect(initPlayer)
	
	Players.PlayerRemoving:Connect(function(player)
		playerScores[player] = nil
		shockwaveCooldowns[player] = nil
	end)
	
	-- ãƒãƒ³ãƒãƒ¼è£…å‚™è¦æ±‚
	SetEquippedHammer.OnServerEvent:Connect(function(player, hammerType)
		hammerType = tostring(hammerType or "BASIC"):upper()
		if not GameConfig.Hammers[hammerType] then hammerType = "BASIC" end
		
		print("[CanService] SetEquippedHammer request:", player.Name, hammerType)

		-- [Hammer Unlock 4/6] è§£æ”¾æ¸ˆã¿ã‹ãƒã‚§ãƒƒã‚¯ï¼ˆã‚¬ãƒ¼ãƒ‰ï¼‰
		local DS = getDataService()
		local data = DS.Get(player)
		local US = getUnlockService()
		if data and US then
			if not US.IsHammerUnlocked(data, hammerType) then
				warn("[CanService] Denied locked hammer request:", player.Name, hammerType)
				return
			end
		end
		
		
		player:SetAttribute("EquippedHammer", hammerType)
		EquipHammerRequest:FireClient(player, hammerType)
		print("[CanService] Equipped:", hammerType)

		-- [æŒ‡ç¤ºæ›¸ 2/2] Revisionä»˜ãåŒæœŸ
		local DS = getDataService()
		local data = DS.Get(player)
		if data then
			data.effectRev = (data.effectRev or 0) + 1
			local hammerMult = 1.0
			local hammerConfig = GameConfig.Hammers[hammerType]
			if hammerConfig and hammerConfig.multipliers then
				hammerMult = hammerConfig.multipliers.NORMAL or 1.0 -- åŸºæœ¬å€ç‡
			end
			player:SetAttribute("HammerMult", hammerMult)

			local PES = getPetEffectService()
			local petBonusMult = PES and PES.getPetBonusMult(player) or 1.0

			local ES = getEffectState()
			local payload = ES.BuildPayload(data, hammerMult, petBonusMult)
			local Net = require(ReplicatedStorage.Shared.Net)
			Net.E("EffectStateSync"):FireClient(player, payload)
			print("[CanService/EffectSync] Hammer Sync sent rev:", data.effectRev, "hm:", hammerMult)
		end
	end)

	-- ç¼¶æ½°ã—ã‚¤ãƒ™ãƒ³ãƒˆ
	CanCrushedEvent.OnServerEvent:Connect(function(player, canModel)
		if not player or not canModel or not canModel.Parent then return end
		if canModel:GetAttribute("ServerHandled") then return end
		
		local hammerType = player:GetAttribute("EquippedHammer") or "BASIC"
		local hammerConfig = GameConfig.Hammers[hammerType]
		
		local canName = canModel.Name
		local canPosition = canModel:GetPivot().Position
		
		-- ãƒ¡ã‚¤ãƒ³ã®ç¼¶ã‚’æ½°ã™
		crushCan(canModel, player, false)
		
		-- SHOCKWAVE / HYBRID ãªã‚‰ã°å‘¨å›²ã‚‚æ½°ã™
		if hammerConfig and hammerConfig.radius then
			local now = tick()
			local cooldown = hammerConfig.cooldown or 10
			local lastUse = shockwaveCooldowns[player] or 0
			
			if (now - lastUse) >= cooldown then
				shockwaveCooldowns[player] = now
				doShockwave(player, canPosition, hammerConfig.radius)
				ShockwaveVFX:FireAllClients(canPosition, hammerConfig.radius, hammerType)
				print("[CanService] Shockwave activated! Radius:", hammerConfig.radius, "CD:", cooldown)
			else
				local remaining = math.ceil(cooldown - (now - lastUse))
				print("[CanService] Shockwave on cooldown:", remaining, "sec")
			end
		end
		
		if GameConfig.PvP and GameConfig.PvP.Enabled then
			-- TODO: PvP Logic
		end
	end)

	print("[CanService] Init Complete")
end

return CanService
